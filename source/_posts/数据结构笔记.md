---
title: 数据结构笔记
categories: learning-notes
excerpt: 如题，数据结构笔记
hide: true
tag: markdown
---

三种符号，描述足够大的问题，可以理解为以下内容
- $\Omicron$：`T(n)<`，其中 $T(n)=\Omicron(f(n))$
- $\Theta$：`T(n)=`，其中 $T(n)=\Theta(f(n))$
- $\Omega$：`T(n)>`，其中 $T(n)=\Omega(f(n))$

$\log^{*}{n}$，表示取多少次对数，值小于等于1，例如对于 $\log^{*}{16}$ 进行三次 $log_{2}$运算后值为1，则 $\log^{*}{16}$ = 3

$\log{n}=\Omicron(\log\log{n})$ 错误
$\log^{*}{n}=\Omicron(\log^{*}(\log{n}))$ 正确，因为 $\log^{*}{n}=\log^{*}(\log{n})+1$

级数求和：
- $\sum_{i=1} i^{p}=\Omicron(n^{p+1}), p为常数$，比幂次高一阶
- $\sum_{i=1}^{n} a^{i}=\Omicron(a^{n})$，与末项同阶
- 调和级数 $\sum_{k=1}^{n} \frac{1}{k}=\Theta(\log n)$
- 对数级数 $\sum_{k=1}^{n} \ln k=\Theta(n \log n)$

减治：将一个大规模问题分为两个子问题，其一平凡（已解决），另一规模缩减
分治：将一个大规模问题分为两个规模几乎相当的子问题

主定理：
分治策略的递推公式形如：$T(n) = aT(\frac{n}{b})+\Omicron(f(n))$ ，表示原问题被分为a个规模大小为n/b的子任务，任务的耗时f(n)


最长公共子序列LCS(Longest Common Subsequence)

平均复杂度
分摊复杂度
当平均复杂度和分摊复杂度相同时，两个互不蕴含

递归算法
- 时间复杂度：递归实例的个数
- 空间复杂度：递归深度
- eg. 斐波那契空间复杂度$\Omicron(n)$，时间复杂度$\Omicron(2^{n})$

二分查找：
- 查找长度：针对查找成功和查找失败，考察关键码的比较次数
  - fibonacci查找，若有n=fib(k)-1，二分的分点是mi=fib(k-1)-1

插值查找：利用向量元素分布规律，根据目标数值，通过插值估计出其大致所对应的秩，缩小搜索范围，称作插值查找；期望运行时间为 $\Omicron(loglogn)$

**逆序对**：不是升序排列的数对（序列中`i<j,且A[i]>A[j]`则为一个逆序对）
- 通过归并的思想可以在$\Omicron(nlogn)$内计算完逆序对个数，

起泡排序：
- 时间效率，最好 $\Omicron(n)$，最坏 $\Omicron(n^{2})$
- 是稳定的（重复元素在输入输出中的相对次序保持不变）
- 交换的次数等于序列所含逆序对的总数

归并排序：
- 分治思想，每个一分为二
- 时间效率，最坏 $\Omicron(nlogn)$
- 是稳定的（出现相同元素，左侧子向量优先）
- 为了避免反复new/delete可以在算法开始时申请一个足够大的缓冲区，作为全局变量使用

位图：
该数据结构提供`set()`,`clear()`,`test()`三种接口，每个接口的时间复杂度均为 $\Omicron(1)$

列表
- 列表等价于双向链表
- 期望复杂度 $(1+2+...+n)/n=\Omicron(n)$
- 插入元素和删除元素的指针顺序
- **循环节**，长度不超过n，循环节之间互不相交

选择排序
- 在无序区中选择一个最大的放到有序区的最小部分
- 找出最大值后基于交换的选择排序会导致不稳定，采用平移法（选择排序一般是用交换）是稳定的（列表的移动复杂度为常数）
- 总体复杂度为 $\Omicron(n^{2})$
- 基于选择排序可以衍生出堆排序（保存了比较中的结果）

插入排序
减而治之
- 在线算法：通过网络传输可以边传输边操作，不必等所有数据都传输完
- 在无序区中取最左边的元素，在有序区中找到合适的位置插入
- 逆序对的间距对算法有影响（输入敏感性）
  - I个逆序对，关键码的比较次数不超过$\Omicron(I)$
  - 有I个逆序对，总运行时间$\Omicron(n+I)$

列表的游标实现：用个数组，一个放数据，另一个放link

---

栈
- 后进先出
- 应用：
  - 进制转换：转换后低位在栈低，高位在栈顶，不断出栈即可实现
  - 括号匹配：遇到左括号进栈，右括号成对消除（分别检查各种括号是否匹配，若分别匹配，则整体匹配的策略错误，反例`({)}`）
  - **栈混洗**(SP,stack permutation)：可能的结果个数
    $$
    SP(n)=\Sigma_{k=1}^{n}SP(k-1)SP(n-k) \\
     =catalan(n) \\
     =\frac{(2n)!}{(n+1)!(n)!}
    $$
    - 以下情况也是Catalan数：
      - n对括号组成的合法表达式种类，Catalan(n)
      - n节点的二叉树形态，Catalan(n)
      - n节点互异的BST种数，Catalan(n)
      - n节点的真二叉树种类（节点的度要么0，要么2），Catalan(n-1)
    - 检测禁形（不可能出现的排列）：对于任意`1<=i<j<k<=n`,`[..., k,...,  i, ..., j, ...>`不可能出现(`>`表示栈顶)
- 中缀表达式求值，需要两个栈，一个操作数栈，一个操作符栈
- 部分非法表达式也可以得到结果
- 逆波兰表达式(Reverse Polish Notation, RPN，后缀表达式)：不使用括号，操作数的次序不变。在求值中只需要一个栈放操作数，从前开始扫描，扫描到操作数入栈，到操作符，操作数栈出栈计算再进栈

队列
- 与栈类似，但先进先出

Steap=Stack+Heap（栈+向量堆）
- 具有`pop`,`push`,`getMax`三种操作，用于求栈中的最大值
- 本质是一个放实际数据的栈和一个维护最大值的栈
- Steap结构的进栈数据栈照常进栈，最大值栈需要`push(max(P.top(),current))`即最大值栈顶和当前数据哪个大哪个进栈；出栈时两个栈都出栈即可；获取最大值时，直接返回最大值栈的栈顶即可。上述操作的复杂度均为$\Omicron(1)$

Queap=Queue+Heap
- 有进队，出队，获取最大值三种操作
- 也是两个队列
- 出队两个队列均出队即可；入队时都入队，但最大值队需要根据入队的数据对原来的数据修改，最坏情况下复杂度可达$\Omicron(n)$；获取最大值时返回最大值队的队尾

双栈当队

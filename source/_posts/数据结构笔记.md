---
title: 数据结构笔记
categories: learning-notes
excerpt: 如题，数据结构笔记
hide: true
tag: markdown
---

三种符号，描述足够大的问题，可以理解为以下内容
- $\Omicron$：`T(n)<`，其中 $T(n)=\Omicron(f(n))$
- $\Theta$：`T(n)=`，其中 $T(n)=\Theta(f(n))$
- $\Omega$：`T(n)>`，其中 $T(n)=\Omega(f(n))$

$\log^{*}{n}$，表示取多少次对数，值小于等于1，例如对于 $\log^{*}{16}$ 进行三次 $log_{2}$运算后值为1，则 $\log^{*}{16}$ = 3

$\log{n}=\Omicron(\log\log{n})$ 错误
$\log^{*}{n}=\Omicron(\log^{*}(\log{n}))$ 正确，因为 $\log^{*}{n}=\log^{*}(\log{n})+1$

级数求和：
- $\sum_{i=1} i^{p}=\Omicron(n^{p+1}), p为常数$，比幂次高一阶
- $\sum_{i=1}^{n} a^{i}=\Omicron(a^{n})$，与末项同阶
- 调和级数 $\sum_{k=1}^{n} \frac{1}{k}=\Theta(\log n)$
- 对数级数 $\sum_{k=1}^{n} \ln k=\Theta(n \log n)$

减治：将一个大规模问题分为两个子问题，其一平凡（已解决），另一规模缩减
分治：将一个大规模问题分为两个规模几乎相当的子问题

主定理：
分治策略的递推公式形如：$T(n) = aT(\frac{n}{b})+\Omicron(f(n))$ ，表示原问题被分为a个规模大小为n/b的子任务，任务的耗时f(n)


最长公共子序列LCS(Longest Common Subsequence)

平均复杂度
分摊复杂度
当平均复杂度和分摊复杂度相同时，两个互不蕴含


二分查找：
- 查找长度：针对查找成功和查找失败，考察关键码的比较次数
  - fibonacci查找，若有n=fib(k)-1，二分的分点是mi=fib(k-1)-1

插值查找：利用向量元素分布规律，根据目标数值，通过插值估计出其大致所对应的秩，缩小搜索范围，称作插值查找；期望运行时间为 $\Omicron(loglogn)$

起泡排序：
- 时间效率，最好 $\Omicron(n)$，最坏 $\Omicron(n^{2})$
- 是稳定的（重复元素在输入输出中的相对次序保持不变）

归并排序：
- 分治思想
- 时间效率，最坏 $\Omicron(nlogn)$
- 是稳定的（出现相同元素，左侧子向量优先）
- 为了避免反复new/delete可以在算法开始时申请一个足够大的缓冲区，作为全局变量使用

位图：
该数据结构提供`set()`,`clear()`,`test()`三种接口，每个接口的时间复杂度均为 $\Omicron(1)$
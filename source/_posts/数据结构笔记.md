---
title: 数据结构笔记
categories: learning-notes
excerpt: 如题，数据结构笔记
hide: true
tag: markdown
---

三种符号，描述足够大的问题，可以理解为以下内容
- $\Omicron$：`T(n)<`，其中 $T(n)=\Omicron(f(n))$
- $\Theta$：`T(n)=`，其中 $T(n)=\Theta(f(n))$
- $\Omega$：`T(n)>`，其中 $T(n)=\Omega(f(n))$

$\log^{*}{n}$，表示取多少次对数，值小于等于1，例如对于 $\log^{*}{16}$ 进行三次 $log_{2}$运算后值为1，则 $\log^{*}{16}$ = 3

$\log{n}=\Omicron(\log\log{n})$ 错误
$\log^{*}{n}=\Omicron(\log^{*}(\log{n}))$ 正确，因为 $\log^{*}{n}=\log^{*}(\log{n})+1$

级数求和：
- $\sum_{i=1} i^{p}=\Omicron(n^{p+1}), p为常数$，比幂次高一阶
- $\sum_{i=1}^{n} a^{i}=\Omicron(a^{n})$，与末项同阶
- 调和级数 $\sum_{k=1}^{n} \frac{1}{k}=\Theta(\log n)$
- 对数级数 $\sum_{k=1}^{n} \ln k=\Theta(n \log n)$

减治：将一个大规模问题分为两个子问题，其一平凡（已解决），另一规模缩减
分治：将一个大规模问题分为两个规模几乎相当的子问题

主定理：
分治策略的递推公式形如：$T(n) = aT(\frac{n}{b})+\Omicron(f(n))$ ，表示原问题被分为a个规模大小为n/b的子任务，任务的耗时f(n)


最长公共子序列LCS(Longest Common Subsequence)

平均复杂度
分摊复杂度
当平均复杂度和分摊复杂度相同时，两个互不蕴含

递归算法
- 时间复杂度：递归实例的个数
- 空间复杂度：递归深度
- eg. 斐波那契空间复杂度$\Omicron(n)$，时间复杂度$\Omicron(2^{n})$

二分查找：
- 查找长度：针对查找成功和查找失败，考察关键码的比较次数
  - fibonacci查找，若有n=fib(k)-1，二分的分点是mi=fib(k-1)-1

插值查找：利用向量元素分布规律，根据目标数值，通过插值估计出其大致所对应的秩，缩小搜索范围，称作插值查找；期望运行时间为 $\Omicron(loglogn)$

**逆序对**：不是升序排列的数对（序列中`i<j,且A[i]>A[j]`则为一个逆序对）
- 通过归并的思想可以在$\Omicron(nlogn)$内计算完逆序对个数，

起泡排序：
- 时间效率，最好 $\Omicron(n)$，最坏 $\Omicron(n^{2})$
- 是稳定的（重复元素在输入输出中的相对次序保持不变）
- 交换的次数等于序列所含逆序对的总数

归并排序：
- 分治思想，每个一分为二
- 时间效率，最坏 $\Omicron(nlogn)$
- 是稳定的（出现相同元素，左侧子向量优先）
- 为了避免反复new/delete可以在算法开始时申请一个足够大的缓冲区，作为全局变量使用

位图：
该数据结构提供`set()`,`clear()`,`test()`三种接口，每个接口的时间复杂度均为 $\Omicron(1)$

列表
- 列表等价于双向链表
- 期望复杂度 $(1+2+...+n)/n=\Omicron(n)$
- 插入元素和删除元素的指针顺序
- **循环节**，长度不超过n，循环节之间互不相交

选择排序
- 在无序区中选择一个最大的放到有序区的最小部分
- 找出最大值后基于交换的选择排序会导致不稳定，采用平移法（选择排序一般是用交换）是稳定的（列表的移动复杂度为常数）
- 总体复杂度为 $\Omicron(n^{2})$
- 基于选择排序可以衍生出堆排序（保存了比较中的结果）

插入排序
减而治之
- 在线算法：通过网络传输可以边传输边操作，不必等所有数据都传输完
- 在无序区中取最左边的元素，在有序区中找到合适的位置插入
- 逆序对的间距对算法有影响（输入敏感性）
  - I个逆序对，关键码的比较次数不超过$\Omicron(I)$
  - 有I个逆序对，总运行时间$\Omicron(n+I)$

列表的游标实现：用个数组，一个放数据，另一个放link

---

栈
- 后进先出
- 应用：
  - 进制转换：转换后低位在栈低，高位在栈顶，不断出栈即可实现
  - 括号匹配：遇到左括号进栈，右括号成对消除（分别检查各种括号是否匹配，若分别匹配，则整体匹配的策略错误，反例`({)}`）
  - **栈混洗**(SP,stack permutation)：可能的结果个数
    $$
    SP(n)=\Sigma_{k=1}^{n}SP(k-1)SP(n-k) \\
     =catalan(n) \\
     =\frac{(2n)!}{(n+1)!(n)!}
    $$
    - 以下情况也是Catalan数：
      - n对括号组成的合法表达式种类，Catalan(n)
      - n节点的二叉树形态，Catalan(n)
      - n节点互异的BST种数，Catalan(n)
      - n叶节点的真二叉树种类，Catalan(n-1)
    - 检测禁形（不可能出现的排列）：对于任意`1<=i<j<k<=n`,`[..., k,...,  i, ..., j, ...>`不可能出现(`>`表示栈顶)
- 中缀表达式求值，需要两个栈，一个操作数栈，一个操作符栈
- 部分非法表达式也可以得到结果
- 逆波兰表达式(Reverse Polish Notation, RPN，后缀表达式)：不使用括号，操作数的次序不变。在求值中只需要一个栈放操作数，从前开始扫描，扫描到操作数入栈，到操作符，操作数栈出栈计算再进栈

队列
- 与栈类似，但先进先出

Steap=Stack+Heap（栈+向量堆）
- 具有`pop`,`push`,`getMax`三种操作，用于求栈中的最大值
- 本质是一个放实际数据的栈和一个维护最大值的栈
- Steap结构的进栈数据栈照常进栈，最大值栈需要`push(max(P.top(),current))`即最大值栈顶和当前数据哪个大哪个进栈；出栈时两个栈都出栈即可；获取最大值时，直接返回最大值栈的栈顶即可。上述操作的复杂度均为$\Omicron(1)$

Queap=Queue+Heap
- 有进队，出队，获取最大值三种操作
- 也是两个队列
- 出队两个队列均出队即可；入队时都入队，但最大值队需要根据入队的数据对原来的数据修改，最坏情况下复杂度可达$\Omicron(n)$；获取最大值时返回最大值队的队尾

双栈当队
直方图最大矩阵算法

---

树
深度：不包括根节点，**根节点深度为0**
高度：叶子深度最大者为高度，空树高度为-1.
一个节点的深度+节点的高度<=树的高度，当该节点为最深的叶子节点时取等

二叉树（节点有序）
- 满树：深度为k的节点所在层，最多有$2^{k}$个节点
- 设度数（出度）为0,1,2的节点各有$n_{0},n_{1},n_{2}$个
  - 边数 $e=n-1=n_{1}+2n_{2}$
  - 当$n_{1}=0$时，为**真二叉树**
  - 叶节点数$n_{0}=n_{2}+1$ 
- 树，二叉树，森林之间可以相互转化
- 遍历算法
  - 前序遍历：VLR，复杂度为$\Omicron(n)$
  - 中序遍历：LVR，类似于节点在x轴上的投影，单次顺着入栈可能有$\Omega(n)$次，需要$\Omega(n)$时间
  - 后序遍历：LRV
  - 层次遍历：使用队列，复杂度$\Omicron(n)$
- 表达式树：叶节点是操作数，非叶节点为操作符
  - 一个表达式可以确定出一个二叉树（给一个序列不能确定出唯一的二叉树）

完全二叉树
- 叶节点都在最低两层里，完全二叉树不一定是真二叉树
- 左满二叉树，右完全；左完全，右满

重构
- **先序或后序+中序**可以确定一个二叉树
- 已知先序和后序不一定能确定一个二叉树（先序根节点的后一个节点一定是左子树，后序根节点的前一个节点一定是右子树，两个节点不同时可以唯一确定），即先序+后序+真二叉树可以唯一确定
- 先序+后序可以确定出层次遍历序列
- 后+层可推先序
- 先+层得不到后

增强序列
- 将NULL的节点补充用"^"替代，构成一个真二叉树，然后输出对应的序列
- 在增强的先序、后序遍历中通过分而治之可以重构出二叉树（中序增强序列无法重构树）

PFC与Huffman编码（**二叉树中左0右1**）
- PFC（前缀无歧义，prefix free code）：不考虑字符权重，字符不必等长，解决歧义。通过平均编码长度考察。字符放在二叉树的叶子节点上
- 最优编码树，真完全二叉树是最优编码树
- Huffman树：考虑字符频率（权重），通过平均带权深度考察，构建算法（维护一个优先级队列）
  - 每个内部节点都有两个孩子。（即真二叉树）
  - 对任一内部节点左右子树互换平均带权深度不变（因此不唯一，且高度也不一定一样）

树的直径：任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

---

图
简单图：不含自环（同一顶点自我邻接）
欧拉环路：各边出现一次
哈密顿环路：各顶点出现一次
支撑树（生成树，spanning tree）：一个图的支撑树不唯一，总权值最小的是最小支撑树（minimum spanning tree），e=n-1
平面图：在平面中边与边不产生交叉，必要条件：e<=3xn-6
欧拉法则：R+V-E=2（R区域个数，V顶点个数，E边的个数）
连通图：任意两个顶点之间都能够连通
有向无环图：DAG（Directed Acyclic Graph）
割：将原图分为两个点集
关节点：将关节点删除之后，原图的连通分量增加
双连通图：没有关节点的图

图的存储：
- 邻接矩阵：顶点的邻接关系，横轴与纵轴表示顶点，交汇处表示有无边，空间$n^{2}$
- 关联矩阵：顶点与边的关联管理，纵轴表示顶点，横轴表示边，交汇处表示点是否与边关联，空间$n*e=n^{3}$，一行代表了与该顶点连接的边有哪些
  - 邻接矩阵与关联矩阵的关系：A邻接矩阵，M关联矩阵，D对角矩阵，表示第i个顶点的度，则$A+D=MM^{T}$
- 邻接多重表：二重列表，每条边只存储一次，一条边一个节点（含有三个指针），空间消耗$\Omicron(n+e)$

BFS（Breadth-First Search）
- 逐圈向外访问，构造出一棵树，使用队列
- 应用：找出连通图，最短路径
- BFS过程中，
  - 队列中的顶点按到s的距离单调排列
  - 首末顶点距s的距离不超过1
  - 从s到v点的路径，是二者在原图中的最短路径

DFS（Depth-First Search）
- 顺着一个方向找到低，然后再换个路找到低
- 经DFS后确定的树边，不会构成回路
- 边的分类
  - tree(v,u)，可以从v进入处于undiscovered状态的u
  - backward(v,u)，从v进入处于discovered状态的u（出现backward必有环，后向边<=回路数）
  - forward(v,u)，从当前v进入处于visited状态的u，且v更早被发现
  - cross(v,u)，从当前v进入处于visited状态的u，且u更早被发现

顶点状态：
- UNDISCOVERED：所有点的初始状态
- DISCOVERED：刚开始被发现（bfs中表现为刚入队）
- VISITED：被访问过并且其所有邻接点也被访问过（bfs中表现为出队）

边的状态：
- UNDETERMINED：未确定的，所有边的初始状态
- TREE：从当前节点v指向undiscovered状态的u节点
- CROSS：dfs与bfs定义不同。bfs指从当前节点v指向非undiscovered状态的u节点；dfs中从当前v进入处于visited状态的u，且u更早被发现
- FORWARD：dfs独有。dfs中从当前v进入处于visited状态的u，且v更早被发现
- BACKWARD：dfs独有。dfs中从当前节点v指向discovered状态的u 

拓扑排序：
- 任给一个有向图，将所有顶点排成一个线性序列
- 可拓扑排序的有向图，必定无环
- 顺序输出零入度顶点
- 逆序输出零出度顶点

优先级搜索：
- 优先级数越大/小，优先级越低/高
- Catley公式：完全图 $K_{n}$ 有 ${n^{n-1}}$ 棵支撑树

Prim算法：最小生成树
Kruskal算法：最小生成树。适用于稀疏图。将所有边按权重排序，迭代每次找最短的边，该边的顶点来自不同的树，将该边连接的两棵树合二为一，共迭代n-1次选出n-1条边。

Dijkstra算法：两点之间的最短路径（各边权重需要为正）。计算S到其余顶点的最短距离
- 某一点到其余点的最短路径的并，形成SPT（shortest path tree）连通且无环，但SPT不一定等于MST

Floyd算法：计算所有点之间的最短距离
- 可以通过调用n次Dijkstra算法$\Omicron(n^{3})$实现folyd一致的结果
- 效率为$\Omicron(n^{3})$，可以出现负权边
- $d^{k}(u,v)$表示u中途经过前k个节点到v的最短距离，则$d^{k}(u,v)\\=w(u,v),if k=0\\=min(d^{k-1}(u,v),d^{k-1}(u,k)+d^{k-1}(k,v),if k≠0)$


关节点
- DFS树中叶节点一定不是关节点
- hca(v)以v为根的子树经后向边能抵达的最高祖先 
- 找关节点划分双连通分量（极大双连通子图）算法，与DFS类似，此处值得**反复揣摩**

并查集：
- 控制树高：路径压缩
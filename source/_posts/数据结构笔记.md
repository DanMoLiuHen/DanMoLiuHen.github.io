---
title: 数据结构笔记
categories: learning-notes
excerpt: 如题，数据结构笔记
hide: true
tag: markdown
---

三种符号，描述足够大的问题，可以理解为以下内容
- $\Omicron$：`T(n)<`，其中 $T(n)=\Omicron(f(n))$
- $\Theta$：`T(n)=`，其中 $T(n)=\Theta(f(n))$
- $\Omega$：`T(n)>`，其中 $T(n)=\Omega(f(n))$

$\log^{*}{n}$，表示取多少次对数，值小于等于1，例如对于 $\log^{*}{16}$ 进行三次 $log_{2}$运算后值为1，则 $\log^{*}{16}$ = 3

$\log{n}=\Omicron(\log\log{n})$ 错误
$\log^{*}{n}=\Omicron(\log^{*}(\log{n}))$ 正确，因为 $\log^{*}{n}=\log^{*}(\log{n})+1$

级数求和：
- $\sum_{i=1} i^{p}=\Omicron(n^{p+1}), p为常数$，比幂次高一阶
- $\sum_{i=1}^{n} a^{i}=\Omicron(a^{n})$，与末项同阶
- 调和级数 $\sum_{k=1}^{n} \frac{1}{k}=\Theta(\log n)$
- 对数级数 $\sum_{k=1}^{n} \ln k=\Theta(n \log n)$

减治：将一个大规模问题分为两个子问题，其一平凡（已解决），另一规模缩减
分治：将一个大规模问题分为两个规模几乎相当的子问题

主定理：
分治策略的递推公式形如：$T(n) = aT(\frac{n}{b})+\Omicron(f(n))$ ，表示原问题被分为a个规模大小为n/b的子任务，任务的耗时f(n)


最长公共子序列LCS(Longest Common Subsequence)

平均复杂度
分摊复杂度
当平均复杂度和分摊复杂度相同时，两个互不蕴含

递归算法
- 时间复杂度：递归实例的个数
- 空间复杂度：递归深度
- eg. 斐波那契空间复杂度$\Omicron(n)$，时间复杂度$\Omicron(2^{n})$

二分查找：
- 查找长度：针对查找成功和查找失败，考察关键码的比较次数
  - fibonacci查找，若有n=fib(k)-1，二分的分点是mi=fib(k-1)-1

插值查找：利用向量元素分布规律，根据目标数值，通过插值估计出其大致所对应的秩，缩小搜索范围，称作插值查找；期望运行时间为 $\Omicron(loglogn)$

**逆序对**：不是升序排列的数对（序列中`i<j,且A[i]>A[j]`则为一个逆序对）
- 通过归并的思想可以在$\Omicron(nlogn)$内计算完逆序对个数，

起泡排序：
- 时间效率，最好 $\Omicron(n)$，最坏 $\Omicron(n^{2})$
- 是稳定的（重复元素在输入输出中的相对次序保持不变）
- 交换的次数等于序列所含逆序对的总数

归并排序：
- 分治思想，每个一分为二
- 时间效率，最坏 $\Omicron(nlogn)$
- 是稳定的（出现相同元素，左侧子向量优先）
- 为了避免反复new/delete可以在算法开始时申请一个足够大的缓冲区，作为全局变量使用

位图：
该数据结构提供`set()`,`clear()`,`test()`三种接口，每个接口的时间复杂度均为 $\Omicron(1)$

列表
- 列表等价于双向链表
- 期望复杂度 $(1+2+...+n)/n=\Omicron(n)$
- 插入元素和删除元素的指针顺序
- **循环节**，长度不超过n，循环节之间互不相交

选择排序
- 在无序区中选择一个最大的放到有序区的最小部分
- 找出最大值后基于交换的选择排序会导致不稳定，采用平移法（选择排序一般是用交换）是稳定的（列表的移动复杂度为常数）
- 总体复杂度为 $\Omicron(n^{2})$
- 基于选择排序可以衍生出堆排序（保存了比较中的结果）

插入排序
减而治之
- 在线算法：通过网络传输可以边传输边操作，不必等所有数据都传输完
- 在无序区中取最左边的元素，在有序区中找到合适的位置插入
- 逆序对的间距对算法有影响（输入敏感性）
  - I个逆序对，关键码的比较次数不超过$\Omicron(I)$
  - 有I个逆序对，总运行时间$\Omicron(n+I)$

列表的游标实现：用个数组，一个放数据，另一个放link

---

栈
- 后进先出
- 应用：
  - 进制转换：转换后低位在栈低，高位在栈顶，不断出栈即可实现
  - 括号匹配：遇到左括号进栈，右括号消除，